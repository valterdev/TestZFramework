# ZFramework

ZFramework - это легковесный фреймворк, с возможностью быстро собирать и переиспользовать различные куски кода (модульность), чтобы собирать игру с разными механиками и метой. От слова Zombie - т.е. возможность фреймворка работать при любых условиях с любым сочетанием модулей.

## Quick Start
Документацию по фреймворку можно открыть в пункте меню:
Window -> ZFramework -> Documentation

В этом же меню можно посмотреть имеющиеся в системе модули и создать свой
Window -> ZFramework -> Module Editor -> All Modules
Window -> ZFramework -> Module Editor -> Create Module

## Требования к архитектуре

При разработке, цель было достигнуть следующих характеристик:
- Низкая связанность, возможность легко заменять механики, мету и прочий функционал игры (Модульность).
- Легкое создание / изменение / замена /удаление модулей приложения
- Удобство и поддерживаемость кода. Устойчивость к регрессии.
- Реактивность — модель данных и интерфейс должны автоматически синхронизироваться.
- Документируемость.
- Легкость тестирования

## Архитектурные решения

В основе лежит многоуровневая архитектура, с различными паттернами на каждом слое.

1. Точкой входа является файл App.cs, расположенный по адресу <b>Assets/App/App.cs</b>
2. Верхнее API приложения строится из потоконезависимых синглтонов (Singleton Pattern). Модульность обеспечивается при помощи возможности языка c# partial class и модуля по управлению всеми модулями системы (Window -> ZFramework -> Module Editor -> All Modules)
3. Глобальный цикл и циклы инициализации реализованы при помощи транзакционных цепочек через таски и промисы. Это позволяет реализовать понятное и гарантированное flow всего приложения. (см. AppTask)
4. Взаимодействие модулей реализовано через хуки пробрасываемые через все приложение (см. Hook)
5. Persistence layer с данными - обеспечивается при помощи механизма глобальных состояний и Scriptable Objects (Observer для реактивности)
6. Взаимодействие с UI реализовано через патерн MVC и Pipes and Filters (используется UI Toolkit)
7. Роутинг UI и главное API реазиовано через паттерн Mediator / Service Locator
8. В целом фреймворк стремится к использованнию: event-driven и data-driven подходов

## R&D

- Feature flagging для модулей.
- Разнообразное наполнение бд с использованием Scriptable Object
- Доработать глобальный цикл приложения
- Разработать аналог event loop у браузеров для более качественной обработки событий и счетчиков. Доработать main loop
- пайплайны для всех отделов разработки
